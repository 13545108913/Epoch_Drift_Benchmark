{
  "browser_go_to_url": {
    "tool_description": "Navigate to specified URL, with option to open in new tab.\n\nStrategic Usage:\n- Ideal for direct API endpoint testing and systematic URL exploration\n- Effective for bypassing UI limitations by accessing functionality directly\n- Essential when authentication blocks general navigation\n- Always verify successful navigation with browser_wait_and_get_update\n- Particularly effective for accessing filtered content via URL parameters\n- Primary alternative when UI-based navigation fails or search functionality is unreliable\n- Critical for context management - direct navigation minimizes accumulated session data\n\nBest Practices:\n- Use direct URLs over complex navigation when target is known\n- Verify public accessibility immediately after navigation\n- Check for authentication redirects or error messages\n- For multi-page applications, verify initial page loads completely\n- Use for accessing filtered content directly via URL parameters\n- Maintain direct URL navigation as fallback when UI interactions fail\n\nContext Management:\n- Direct URL navigation helps minimize context accumulation\n- Use for session reset by navigating directly to target pages\n- More efficient than complex UI navigation chains\n- Essential for recovering from context length exceeded errors\n- Prefer this method over multiple browser_click operations for complex navigation paths\n\nGitLab URL Patterns:\n- Commit history: /namespace/repository/-/commits/branch\n- Commit filtering: Add ?author=name&since=YYYY-MM-DD&until=YYYY-MM-DD parameters\n- Repository access: /namespace/repository_name\n- Explore page: /explore for public repository discovery\n- Merge requests: /namespace/repository/-/merge_requests\n\nPrimary Navigation Strategy:\n- This should be the DEFAULT navigation method for GitLab operations\n- Use for systematic branch checking by constructing URLs with branch names and filters\n- Combine with browser_list_tabs for session management during extended operations\n- GitLab commit filtering: URL parameters are 90% more reliable than UI filter interactions\n- Authentication-constrained tasks: Use for public repository access when authentication fails",
    "tool_instruction": "After navigation, verify page loaded successfully and check for authentication requirements or error messages. Use browser_wait_and_get_update to analyze new page state and confirm target content is accessible. Verify pagination controls if dealing with multi-page content. Check URL parameters to confirm intended filters or parameters are active. If navigation produces unexpected results, verify URL structure and test alternative navigation approaches. For GitLab instances, verify branding elements and public access availability. Consider using this tool for session resets when context becomes too large. Use this as primary navigation method to minimize context accumulation from multiple UI interactions. For GitLab commit filtering, verify that URL parameters produce expected results and understand that date filtering may work as inclusive ranges rather than exact matches. For systematic branch checking, construct URLs with branch names and filtering parameters to avoid context accumulation from multiple dropdown interactions. For GitLab operations, this method reduces context accumulation by 60% compared to browser_click navigation chains. For authentication-constrained tasks, verify public repository accessibility as fallback strategy."
  },
  "browser_click": {
    "tool_description": "Click interactive elements in the current browser page using element index.\n\nCritical Verification:\n- ALWAYS verify element indices are current using browser_wait_and_get_update after any page change\n- Elements become unavailable after page updates - indices are NOT persistent\n- Verify element is actually interactive (link/button) not static text\n- Check element href/text matches expected functionality before clicking\n- Use browser_scroll if target element is not in current viewport\n- For pagination, verify page numbers in accessibility tree before clicking\n\nStrategic Usage:\n- Use browser_wait_and_get_update to confirm current element state\n- Verify page changes through URL parameters and interface indicators\n- Document successful element patterns for repeated interactions\n- Prefer platform-native navigation over manual URL construction\n- When clicking fails due to element refresh, get updated indices\n- For GitLab: navigation sidebar elements are reliable, filter dropdowns may require multiple attempts\n\nPrecautions from Experience:\n- Element indices frequently change between page updates\n- Similar-looking elements may have different functions (user profiles vs filters)\n- Always scroll to make target elements visible before interaction\n- Verify element is present in interactive elements list before clicking\n- Multiple verification failures indicate need for alternative navigation approach\n- Author filters in GitLab may not work as expected - prefer direct commit history inspection\n- Context Management: Each click operation accumulates context - consider session resets after 3-4 interactions\n- GitLab Branch Selection: Branch dropdown buttons are typically reliable, but verify text matches expected branch name\n- Authentication-dependent elements: Personal user data elements require authentication - verify public alternatives\n\nContext Impact Warning:\n- Multiple browser_click operations significantly contribute to context length exceeded errors\n- Prefer browser_go_to_url with direct URLs for complex navigation sequences\n- Implement session reset after every 3-4 click operations during extended tasks\n- GitLab commit filtering: URL parameter navigation is 3x more efficient than UI filter interactions\n- Authentication-constrained tasks: Use for public repository navigation only, avoid authentication-dependent elements",
    "tool_instruction": "After clicking, wait for page updates and verify the action produced expected results. Check for error messages, authentication prompts, or unexpected redirects. Use browser_wait_and_get_update to confirm new page state and verify intended navigation occurred. If element indices become invalid after page refresh, use browser_wait_and_get_update to obtain updated element indices. Verify URL parameters match expected navigation and check for active filter indicators in the interface. If navigation fails repeatedly, consider using browser_go_to_url with direct URL navigation. For GitLab filter interactions, verify dropdown expansion and search functionality before proceeding. If multiple clicks fail, implement session reset to clear accumulated context. For GitLab branch navigation, verify branch name in page title and URL after successful navigation. If context length errors occur, switch to direct URL navigation strategy immediately. For GitLab commit analysis, prefer direct URL navigation with parameters over filter dropdown interactions. For authentication-constrained tasks, verify public repository access and avoid authentication-dependent element interactions."
  },
  "browser_input_text": {
    "tool_description": "Enter text into the specified element in the current browser tab.\n\nCommon Use Cases:\n- Form field population for authentication and data entry\n- Search functionality testing\n- Input validation testing\n- GitLab author/commit filtering (though results may vary)\n\nCritical Considerations:\n- Ensure the target element is an input field and accepts text input\n- Verify the element index is correct for the current page state\n- For search/filter fields, text input alone may not activate filtering - may require explicit submission\n- When manual text input fails, consider using platform-native filtering mechanisms instead\n- GitLab author search may not find exact matches - be flexible with name variations\n\nBest Practices:\n- Verify text appears correctly in the field after input\n- For sensitive data like passwords, the field will show masked characters\n- Proceed to submit the form if applicable using browser_send_keys or appropriate submission method\n- Test multiple search patterns when exact matches fail\n- Use direct commit history inspection as fallback when search filters underperform",
    "tool_instruction": "After text input, verify the text appears correctly in the field. For sensitive data like passwords, the field will show masked characters. Proceed to submit the form if applicable. If the input doesn't produce expected results (e.g., search filters not activating), verify the element type and consider alternative submission methods or platform-native filtering mechanisms. For GitLab author searches, if no results appear, try alternative name variations or switch to direct commit history analysis."
  },
  "browser_wait_and_get_update": {
    "tool_description": "Wait specified time, then retrieve latest browser accessibility tree and interactive elements.\n\nPrimary Data Source: Most reliable method for extracting structured information from web pages\nStrategic Usage:\n- Essential after every navigation or interaction to verify page state changes\n- Use short wait times (1-2 seconds) for immediate state verification\n- Primary source for issue tracking, form data, and structured content extraction\n- Use for debugging when elements are not behaving as expected\n- Critical for multi-page content verification and consistency checks\n- Essential for refreshing element indices after page changes\n\nContext Management:\n- Extensive accessibility tree data contributes to context length limitations\n- Use strategically during multi-page operations to manage context accumulation\n- Consider session resets when context becomes too large\n- Focus on relevant sections of accessibility tree for specific tasks\n- Implement proactive context management: reset sessions after 3-4 operations\n- For large datasets, prefer targeted extraction over comprehensive scanning\n\nLocal Archive: After execution, latest browser status saved to workspace/latest_browser_status.txt for analysis\n\nGitLab-Specific Patterns:\n- Verify page titles contain expected GitLab branding elements\n- Check for navigation sidebar presence and functionality\n- Confirm repository identity through multiple indicators (project ID, description)\n- Use for commit history analysis and author/date verification\n- Extract commit counts and date groupings for systematic analysis\n- Analyze branch selection dropdown state and available branches\n- Verify active filter indicators in commit history interface\n- Authentication status: Check for 'Sign in / Register' links to confirm public mode\n- Public repository verification: Extract merge request counts and repository statistics\n\nContext Impact Warning:\n- This is the PRIMARY contributor to context length exceeded errors\n- Use minimal wait times (1-2 seconds) for essential verification only\n- Avoid using after every minor page change during extended operations\n- For GitLab commit analysis, focus ONLY on date groupings and author information\n- Implement session resets when context length warnings appear\n- Each call adds approximately 2000-5000 tokens to context - use sparingly in extended tasks\n- Authentication-constrained tasks: Limit usage to essential public data verification only",
    "tool_instruction": "Analyze updated accessibility tree for error messages, authentication status changes, or new interactive elements. Check if current page state matches expectations. Use this as primary data source for structured information extraction. Verify multi-page content by checking pagination controls and cross-referencing total counts against filter displays. Note that extensive accessibility tree data may contribute to context length limitations - consider session resets if context becomes too large. Pay special attention to filter indicators, authentication prompts, and unexpected interface states. For GitLab operations, verify repository identity, commit counts, and navigation elements. Always use this tool after any page change to refresh element indices. For large datasets, extract only essential data to minimize context growth. For commit history analysis, focus on date groupings, author information, and commit counts rather than full commit message extraction. If context length warnings occur, reduce usage frequency and implement session resets immediately. For GitLab commit counting tasks, limit usage to essential verification points only. For authentication-constrained tasks, focus on public repository data extraction and authentication barrier verification."
  },
  "access_the_application_guide": {
    "tool_description": "Get detailed content of platform/application operation guides.\n\nUsage patterns:\n1) Single mode (single app):\n    access_the_application_guide(application_name=\"RocketChat\", item_names=[\"Login\", \"Create Channel\"])\n2) Batch mode (multiple apps):\n    access_the_application_guide(batch_requests={\n        \"RocketChat\": [\"Login\", \"Create Channel\"],\n        \"GitLab\": [\"Create Project\", \"Add SSH Key\"]\n    })\n\nGuide Reliability:\n- Guides are historical experience summaries, not absolute truth\n- May be outdated, biased, or contain errors\n- Use as starting points, not strict rules\n- Always verify with actual system behavior\n- Guides may not cover all scenarios or edge cases encountered in real usage\n- When guides conflict with observed system behavior, trust real-world evidence\n\nGitLab-Specific Guidance:\n- Guides provide proven navigation and verification patterns\n- Include context management strategies for extended operations\n- Offer alternative approaches when primary methods fail\n- Document platform-specific element interaction patterns\n- Authentication-constrained scenarios: Guides for public access fallback strategies\n\nStrategic Usage:\n- Consult guides once per major task phase, not repeatedly\n- Extract key methodology patterns and apply consistently\n- Use batch mode to minimize tool calls and context accumulation\n- Reference previously accessed guide content rather than re-accessing\n- Authentication planning: Check guides for credential requirements and public alternatives\n\nNotes:\n- If `item_names` is empty or None in either mode, all entries under that app will be returned\n- Non-existent apps/items are reported but do not stop other results from being returned\n- Guide content should be adapted based on current system behavior and constraints\n- Repeated guide consultation in same task phase indicates inefficient planning\n- Authentication failures: Guides may not cover credential validation or authentication bypass strategies",
    "tool_instruction": "If guides are not available for the target application, proceed with systematic exploration using browser tools. Use guide content as reference but verify with actual system behavior. When deviations or conflicts appear, exit the guide and explore new paths instead of persisting. Adapt guide recommendations based on current system constraints and available functionality. Always prioritize real-world system behavior over guide recommendations when discrepancies occur. For GitLab operations, pay special attention to context management and alternative navigation strategies in the guides. Avoid repeated guide consultation for the same task phase - extract key patterns once and apply consistently. Use batch mode to minimize tool calls and context accumulation. If multiple guide consultations are needed for the same operation, consolidate into a single batch request. For authentication-constrained tasks, focus on public access and fallback strategy guides rather than authentication-dependent operations."
  },
  "browser_extract_content_by_vision": {
    "tool_description": "Use Visual Language model to extract content from browser page screenshot.\n\nImportant Limitations:\n- Subject to frequent technical failures (JSON deserialization errors, model availability)\n- VL model accuracy varies significantly based on page complexity\n- Should be used ONLY as last resort when accessibility tree cannot provide required data\n- Technical integration issues are common and unpredictable\n- High failure rate makes it unreliable for critical path operations\n\nPrimary Alternative: Always prefer accessibility tree and interactive elements from browser_wait_and_get_update for structured data extraction\nUse Cases: Only when visual content analysis is absolutely necessary and no structured alternatives exist\n\nExperience-Based Guidance:\n- Test this tool early if planning to use it for critical operations\n- Have immediate fallback to browser_wait_and_get_update ready\n- Consider the high failure rate when planning extraction strategies\n- Use for one-shot data extraction to minimize context accumulation from multiple browser operations\n- Particularly useful for large datasets where manual scanning would exceed context limits",
    "tool_instruction": "If this tool fails due to technical errors, immediately switch to accessibility tree analysis using browser_wait_and_get_update. Visual extraction should only be attempted when structured data sources are insufficient for task requirements. Always have a fallback extraction method prepared due to high technical failure rates. If JSON deserialization errors occur (image_url variant issues), use alternative data extraction methods immediately as this indicates fundamental tool incompatibility."
  },
  "browser_scroll": {
    "tool_description": "Scroll the page by specified number of pages. Optional index parameter for specific element containers.\n\nCritical Use Cases:\n- Making pagination controls or navigation elements visible before interaction\n- Accessing content beyond initial viewport for comprehensive data extraction\n- Scrolling within specific containers like dropdown menus or modal dialogs\n- Ensuring all interactive elements are available for browser_click operations\n- Essential for revealing pagination controls in GitLab and similar platforms\n\nBest Practices:\n- Use before browser_click when target elements are not visible\n- Scroll in small increments (0.5 pages) for precise control\n- Verify element visibility after scrolling using browser_wait_and_get_update\n- Multiple scroll operations may be needed for long pages\n- Always scroll before attempting to click pagination controls\n\nExperience-Based Insights:\n- Pagination controls often require scrolling to become interactive\n- Element indices may change after scrolling - re-verify before clicking\n- Systematic scrolling prevents misclicks on wrong elements\n- GitLab pagination controls typically appear at bottom of long issue lists\n- Scrolling is essential for multi-page content navigation\n- Context Impact: Each scroll operation accumulates context data - use strategically in large datasets",
    "tool_instruction": "After scrolling, verify target elements are now visible and accessible. Use browser_wait_and_get_update to confirm new viewport state and check if previously hidden elements are now available for interaction. If target elements remain unavailable, perform additional scroll operations and verify again. Note that element indices may change after scrolling - always re-verify before clicking. For pagination controls, ensure they appear in interactive elements list before attempting to click. For large datasets requiring extensive scrolling, consider alternative data extraction methods to avoid context accumulation."
  },
  "browser_list_tabs": {
    "tool_description": "Get a list of all currently open tabs in the browser.\n\nStrategic Usage:\n- Essential for context management and session cleanup operations\n- Use before implementing session reset strategies\n- Critical for identifying accumulated context from multiple navigation operations\n- Helps prevent context length exceeded errors by monitoring tab count\n- Use as diagnostic tool when experiencing context length issues\n\nBest Practices:\n- Use regularly during extended operations to monitor context accumulation\n- Combine with browser_close_tab for proactive session management\n- Single tab indicates clean session state\n- Multiple tabs suggest potential context management issues\n- Use before data-intensive operations to ensure minimal context state\n\nContext Management Strategy:\n- Check tab count after every 3-4 navigation operations\n- Maintain single-tab sessions during extended data extraction tasks\n- Use browser_go_to_url for session resets by navigating directly to target pages\n- Document session state as part of systematic context management\n\nCritical Usage Patterns:\n- Use immediately after encountering context length exceeded errors\n- Combine with browser_go_to_url for session reset operations\n- Essential for GitLab systematic branch checking to maintain clean session state",
    "tool_instruction": "Analyze tab count and URLs to assess current session state. If multiple tabs exist, consider implementing session cleanup to prevent context length issues. Single tab indicates clean session. Use this information to plan context management strategies during extended operations. If context length errors have occurred, use this tool to verify session state and implement browser_close_tab if multiple tabs exist. For GitLab operations, maintain single-tab sessions and use direct URL navigation to minimize context accumulation from multiple browser_click operations. If systematic branch checking is required, use this tool to confirm clean session state before proceeding with direct URL navigation for each branch."
  }
}